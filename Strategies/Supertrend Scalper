//@version=5
// indicator("Scalping Bot 1.0", overlay=true, timeframe="", timeframe_gaps=true)
strategy("Scalping Bot 1.0", overlay=true)


supertrendGroup = "Super Trend"
tradingSession = input.session("1300-1700", "Session")

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////// S U P E R T R E N D    I N I T I A L I Z A T I O N ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HeikinA = input(false, title='Use Heikin Ashi')

Price = input(open, "Super Trned Source input", group = supertrendGroup)
src = HeikinA ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, Price, lookahead=barmerge.lookahead_off) : Price
// src := request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, src, lookahead=barmerge.lookahead_off)
// Supertrend 1
atrPeriod1 = input(10, "ATR1 Length", inline = "3", group = supertrendGroup)
factor1 = input.float(1.5, "Factor1", step = 0.1, inline = "3", group = supertrendGroup)

[supertrend1, direction1] = ta.supertrend(factor1, atrPeriod1)

// bodyMiddle1 = plot((open + close) / 2, display=display.none)
upTrend1 = plot(direction1 < 0 ? supertrend1 : na, "Up Trend", color = color.green, style=plot.style_linebr, display = display.none)
downTrend1 = plot(direction1 < 0? na : supertrend1, "Down Trend", color = color.red, style=plot.style_linebr, display = display.none)

// Supertrend 2
atrPeriod2 = input(11, "ATR2 Length", inline = "4", group = supertrendGroup)
factor2 = input.float(2.0, "Factor2", step = 0.1, inline = "4", group = supertrendGroup)

[supertrend2, direction2] = ta.supertrend(factor2, atrPeriod2)

// bodyMiddle2 = plot((open + close) / 2, display=display.none)
upTrend2 = plot(direction2 < 0 ? supertrend2 : na, "Up Trend", color = color.green, style=plot.style_linebr, display = display.none)
downTrend2 = plot(direction2 < 0? na : supertrend2, "Down Trend", color = color.red, style=plot.style_linebr, display = display.none)

// Supertrend 3
atrPeriod3 = input(12, "ATR3 Length", inline = "5", group = supertrendGroup)
factor3 = input.float(3.0, "Factor3", step = 0.1, inline = "5", group = supertrendGroup)

[supertrend3, direction3] = ta.supertrend(factor3, atrPeriod3)

// bodyMiddle3 = plot((open + close) / 2, display=display.none)
upTrend3 = plot(direction3 < 0 ? supertrend3 : na, "Up Trend", color = color.green, style=plot.style_linebr, display = display.none)
downTrend3 = plot(direction3 < 0? na : supertrend3, "Down Trend", color = color.red, style=plot.style_linebr, display = display.none)


direction2:= direction1
direction3:= direction1
atrPeriod2 := atrPeriod1
atrPeriod3 := atrPeriod1

directionIsSame = if ((direction1 == direction2) and (direction2  == direction3) and (direction3  == direction1))
    true
else
    false



////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// H U L L    S U I T E    A V E R A G E  ////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HMAGroup = "HMA"
Hsrc = input(close, title="Hull Source", group = HMAGroup)
Hlength = input(55, title="Length", group = HMAGroup)
HlengthMult = input(1.0, title="Length multiplier", group = HMAGroup)
HthicknesSwitch = input(1, title="Line Thickness", group = HMAGroup)

EHMA(_src, _length) =>  ta.ema(2 * ta.ema(_src, _length / 2) - ta.ema(_src, _length), math.round(math.sqrt(_length)))
_hull = EHMA(src, int(Hlength * HlengthMult))
HULL = _hull
MHULL = HULL[0]
hullDirection = (HULL > HULL[2])

// if hull direction is true means that it is going up otherwise it is down
hullColor = (hullDirection ? #00ff00 : #ff0000)
plot(MHULL, title="MHULL", color=hullColor, linewidth=HthicknesSwitch)



////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// L A G U E R R E    F I L T E R ////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////



// Lsrc = input(hl2, "Laguerre Source")
// Lalpha = input.float(0.1, "Alpha", step = 0.01)
// gamma = 1 - Lalpha
// var float L0 = na
// L0 := na(L0[1]) ? (1 - gamma) * src + gamma * nz(L0[1]) : (1 - gamma) * src + gamma * L0[1]
// var float L1 = na
// L1 := na(L1[1]) ? -gamma * L0 + nz(L0[1]) + gamma * nz(L1[1]) : -gamma * L0 + L0[1] + gamma * L1[1]
// var float L2 = na
// L2 := na(L2[1]) ? -gamma * L1 + nz(L1[1]) + gamma * nz(L2[1]) : -gamma * L1 + L1[1] + gamma * L2[1]
// var float L3 = na
// L3 := na(L3[1]) ? -gamma * L2 + nz(L2[1]) + gamma * nz(L3[1]) : -gamma * L2 + L2[1] + gamma * L3[1]
// LagF = (L0 + 2 * L1 + 2 * L2 + L3) / 6
// LaguerreDirection = (LagF > LagF[1])
// Color = LaguerreDirection ? color.green : color.red
// plot(LagF, title="LagF", linewidth=2, color=Color, transp=0)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// R A N G E    I D E N T I F I E R/////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RangeGroup = "RSI SETTINGS"

bool isRanging = false
RSIma(source, length, type) =>
    switch type
        "SMA" => ta.sma(source, length)
        "EMA" => ta.ema(source, length)
        "SMMA (RMA)" => ta.rma(source, length)
        "WMA" => ta.wma(source, length)
        "VWMA" => ta.vwma(source, length)
rsiLengthInput = input.int(37, minval=1, title="RSI Length", group=RangeGroup, inline = "1")
rsiSourceInput = input.source(close, "Source", group=RangeGroup, inline = "1")
maTypeInput = input.string("EMA", title="MA Type", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group=RangeGroup, inline = "2")
maLengthInput = input.int(38, title="MA Length", group=RangeGroup, inline = "2")
rsiLookback = input.int(15, title = "Look Back Period", group=RangeGroup, inline = "3")
rsiSpread = input.int(4, title = "RSI Spread", group=RangeGroup, inline = "3")
rsiUpperBandValue = 50+rsiSpread
rsiLowerBandValue = 50-rsiSpread

up = ta.rma(math.max(ta.change(rsiSourceInput), 0), rsiLengthInput)
down = ta.rma(-math.min(ta.change(rsiSourceInput), 0), rsiLengthInput)
rsi = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))
rsiMA = RSIma(rsi, maLengthInput, maTypeInput)

numberOfTimesInRange = 0

for i = 0 to rsiLookback
    if(rsiMA[i] < rsiUpperBandValue and rsiMA[i] > rsiLowerBandValue)
        numberOfTimesInRange := numberOfTimesInRange + 1

if(numberOfTimesInRange >= rsiLookback)
    isRanging := true
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// P O S I T I O N    L O G I C /////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Lets rewrite the entire code

// Create buy sell variables
bool buy = false
bool sell = false
bool exitOut = false

// logic variables

// isInTradingSession checks if time is in between 
bool isInTradingSession = time(timeframe.period, tradingSession)

// bool isRanging // Checks if rsi is ranging; this is already definded

// Checks if hullIsAlgo going up or down
bool hullGoingUp = hullDirection
bool hullGoingDown = not hullDirection

// Checks if super trend is going up or down; direction < 0 means up
bool supertrendGoingUp = (directionIsSame) and (direction1 < 0)
bool supertrendGoingDown = (directionIsSame) and (direction1 > 0)


// Only place a buy if the last bar was not a buy


// You can place a buy/sell if 
    // 1. Supertrend Directions are all the same
    // 2. HMA Direction is the same as Supertrend direction
    // 3. RSI is not currently ranging

// You can only exit out if
    // The supertrend direction changes or tradingSession Ends
    // If directionIsSame[1] but not for directionIsSame[0]


// Logic flow:
// if is in trading session --> super trend direction is same --> if the last one was not also a buy/sell and its not continueing --> check if you can buy/sell
// rewrite everything

if not isInTradingSession  // If it is not in trading session, exit out of all positions
    buy     := false
    sell    := false
    exitOut := true
else if not directionIsSame // If the direction is no longer the same, exit out
    buy     := false
    sell    := false
    exitOut := true
else if (buy[1] and supertrendGoingUp and directionIsSame) // if direction is the same, going up and the last one was a buy, keep buy 
    buy     := true
    sell    := false
    exitOut := false
else if (sell[1] and supertrendGoingDown and directionIsSame) // if direction is the same, going down and the last one was a sell, keep sell
    buy     := false
    sell    := true
    exitOut := false
else if (not buy[1] and supertrendGoingUp and hullGoingUp and (not isRanging) and directionIsSame) // if last one was not a buy and everything is going up and not ranigng buy
    buy     := true
    sell    := false
    exitOut := false
else if (not sell[1] and supertrendGoingDown and hullGoingDown and (not isRanging) and directionIsSame) // if last one was not a sell and everything is going down and not ranigng sell
    buy     := false
    sell    := true
    exitOut := false
else
    buy     := false
    sell    := false
    exitOut := true


// if (supertrendGoingUp and hullGoingUp and not isRanging) // If everything is all going up and is not ranging
//     buy := true
// else if (supertrendGoingDown and hullGoingDown and not isRanging) // If everything is all going down and is not ranging
//     sell := true
// else if (not directionIsSame) // this means everything else is false. make sure to do if the last candle was a buy and and direction is still same, then keep buy true
//     exitOut := true
// else if (buy[1] and supertrendGoingUp) // if the last one was a buy and the direction is still the same keep the buy
//     buy := true
// else if (sell[1] and supertrendGoingDown) // if the last candle was a sell and the direction is still the same, keep the buy
//     sell := true

// // Do a hard set exit
// if not isInTradingSession
//     buy := false
//     sell := false
//     exitOut := true
// else if (not directionIsSame)
//     buy := false
//     sell := false
//     exitOut := true





// isTrending = ta.tr(true) > lowVolatility

// Is tradingSession

// canTrade = time(timeframe.period, tradingSession) and directionIsSame and not isRanging


///////////////////// U N C O M M E N T    T H I S    I F    I T    D O E S N T    W O R K
// canTrade = time(timeframe.period, tradingSession) and directionIsSame


// bothSame = if directionIsSame and direction1 < 0 and hullDirection
//     true
// else if directionIsSame and direction1 > 0 and not hullDirection
//     true
// else
//     false


// if(canTrade and bothSame) // This logic needs to be fixed
//     if(direction1<0)
//         if(not isRanging)
//             buy := true
//         else if(buy[1])
//             buy := true
//     else if(direction1>0 )
//         if(not isRanging)
//             sell := true
//         else if(sell[1])
//             sell := true
// else        
//     exitOut := true

// Current issue: it exits out as soon as it enters a range
// But rather it should be that i t should not enter in a range but can hold in a range
// modify this so that it checks if there is a position entered, and only exit once the stoploss has been HthicknesSwitch

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// T R A D E        S I Z E        L O G I C //////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// Calculate the number of lot
accountInfoGroup = "Account Info"


account_balance = input(10000, "Account Balance", group = accountInfoGroup)
float  risk_percentage = input.float(1, "Risk Percentage", group = accountInfoGroup)

risk_percentage := risk_percentage/100
float stopLossDistance = na

if(buy == true)
    stopLossDistance:=(close-supertrend2)
if(sell == true)
    stopLossDistance:=(supertrend2-close)


number_of_lots = math.abs(account_balance*risk_percentage / (stopLossDistance))

// if bar_index % 1 == 0
//     label.new(bar_index, na, "Number of pips = " + str.tostring(math.abs(stopLossDistance), format.mintick) + "\nðŸ ‡", yloc = yloc.abovebar, style = label.style_none, textcolor = color.white, size = size.normal)


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// P L O T        G R A P H S ////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Plot Labels
barColor = if(buy)
    color.green
else if(sell)
    color.red
else if(isRanging)
    color.purple
else
    color.gray


plotcandle(open, high, low, close, title='Bar', color = barColor, wickcolor= barColor)

// If the current one says to buy but the last one wasnt a buy, that means this is the first buy signal
plotshape(buy and not buy[1], style = shape.labelup, location = location.belowbar, 
         color = color.green, size = size.small, text = "B", textcolor = color.white)
plotshape(sell and not sell[1], style = shape.labeldown, location = location.abovebar, 
         color = color.red, size = size.small, text = "S", textcolor = color.white)
plotshape(exitOut and not exitOut[1], style = shape.labeldown, location = location.abovebar, 
         color = color.yellow, size = size.small, text = "E", textcolor = color.white)

strategy.entry("Long", strategy.long, number_of_lots, when = buy)
strategy.entry("Short", strategy.short, number_of_lots, when = sell)

strategy.close("Long", when = sell or exitOut)
strategy.close("Short", when = buy or exitOut)
