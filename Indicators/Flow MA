//@version=6
indicator("Flow MA - Hybrid Intelligence", overlay=true)

//──────────────────────────────── Inputs
intelligence = input.int(20, "Intelligence Period", minval=5, maxval=200,
  tooltip="Period for all calculations - fractal dimension, efficiency ratio, and base smoothing")

erPower = input.float(2.0, "ER Adaptability", minval=0.5, maxval=4.0, step=0.5,
  tooltip="How aggressively efficiency ratio controls adaptation. Higher = more extreme switching between fast/slow")

//──────────────────────────────── THE HYBRID ENGINE
flow_hybrid(src, intel, erAdapt) =>
    
    // ═══════════════════════════════════════════════════════
    // PART 1: FRACTAL DIMENSION (from FRAMA)
    // ═══════════════════════════════════════════════════════
    
    len = intel
    half = len / 2
    
    // Split period into two halves and measure ranges
    float n1 = (ta.highest(high, half) - ta.lowest(low, half)) / half
    float n2 = (ta.highest(high[half], half) - ta.lowest(low[half], half)) / half
    float n3 = (ta.highest(high, len) - ta.lowest(low, len)) / len
    
    // Calculate fractal dimension: 1.0 = trend, 2.0 = range
    float dimension = (n1 > 0 and n2 > 0 and n3 > 0) ? 
                      (math.log(n1 + n2) - math.log(n3)) / math.log(2.0) : 1.5
    dimension := math.min(math.max(dimension, 1.0), 2.0)
    
    // ═══════════════════════════════════════════════════════
    // PART 2: EFFICIENCY RATIO (from KAMA)
    // ═══════════════════════════════════════════════════════
    
    // Signal: Net directional change
    float signal = math.abs(src - src[len])
    
    // Noise: Total path traveled
    float noise = 0.0
    for i = 0 to len - 1
        noise += math.abs(src[i] - src[i + 1])
    
    // Efficiency: 1.0 = perfect trend, 0.0 = pure chop
    float efficiency = (noise > 0) ? signal / noise : 0.0
    
    // ═══════════════════════════════════════════════════════
    // PART 3: JMA FOUNDATION
    // ═══════════════════════════════════════════════════════
    
    float power = 0.45
    float beta = power * (len - 1) / ((power * (len - 1)) + 2)
    float len1 = math.max(math.log(math.sqrt(0.5 * (len - 1))) / math.log(2.0) + 2.0, 0)
    float pow1 = math.max(len1 - 2.0, 0.5)
    
    // ═══════════════════════════════════════════════════════
    // PART 4: HYBRID ADAPTIVE ALPHA
    // ═══════════════════════════════════════════════════════
    
    // FRAMA: fractal dimension determines base speed
    float framaAlpha = math.exp(-4.6 * (dimension - 1.0))
    framaAlpha := math.min(math.max(framaAlpha, 0.01), 1.0)
    
    // KAMA: efficiency ratio acts as the SELECTOR
    // This is the key - ER decides HOW MUCH to use FRAMA vs JMA
    // erPower controls how aggressively this selection happens
    float kamaWeight = math.pow(efficiency, erAdapt)
    
    // JMA: stable baseline
    float jmaAlpha = math.pow(beta, 1.0 / pow1)
    
    // HYBRID: blend based on powered efficiency
    float alpha = kamaWeight * framaAlpha + (1.0 - kamaWeight) * jmaAlpha
    alpha := math.min(math.max(alpha, 0.01), 0.95)
    
    // ═══════════════════════════════════════════════════════
    // PART 5: DUAL-STAGE SMOOTHING
    // ═══════════════════════════════════════════════════════
    
    var float ma1 = na
    var float det0 = na
    var float det1 = na
    var float result = na
    
    ma1 := na(ma1) ? src : src + (alpha * (ma1 - src))
    det0 := na(det0) ? 0.0 : (src - ma1) * (1.0 - beta) + beta * det0
    float ma2 = ma1 + 1.5 * det0
    
    float alphaSq = alpha * alpha
    float oneMinusAlphaSq = (1.0 - alpha) * (1.0 - alpha)
    det1 := na(det1) ? 0.0 : (ma2 - nz(result, src)) * oneMinusAlphaSq + alphaSq * det1
    result := na(result) ? src : nz(result, src) + det1
    
    [result, dimension, efficiency, alpha]

//──────────────────────────────── Execution
[flowMA, fractalD, efficiencyER, adaptiveAlpha] = flow_hybrid(close, intelligence, erPower)

//──────────────────────────────── Market State Detection
bool isTrending = fractalD < 1.4 and efficiencyER > 0.3
bool isRanging = fractalD > 1.6 or efficiencyER < 0.15

//──────────────────────────────── Coloring
float momentum = flowMA - nz(flowMA[1], flowMA)

color maColor = 
  isTrending and momentum > 0 ? color.rgb(0, 255, 0) :
  isTrending and momentum < 0 ? color.rgb(255, 0, 0) :
  not isTrending and not isRanging ? color.rgb(255, 165, 0) :
  color.rgb(128, 128, 128)

//──────────────────────────────── Plotting
plot(flowMA, "Flow MA", color=maColor, linewidth=3)
