//@version=6
indicator("Flow MA", overlay=true, max_bars_back=5000)

//──────────────────────────────── Inputs
grp_main = "Core Settings"
srcInput = input.source(close, "Source", group=grp_main)
period   = input.int(20, "Period", minval=2, group=grp_main)
// Phase is hard-coded to -100
// Power is hard-coded to 0.1

grp_lock = "Range Lock Logic"
lockMult = input.float(0.6, "Lock Threshold", minval=0.1, maxval=2.0, step=0.1, group=grp_lock, tooltip="Lower = stays flat more often. Higher = follows price more.")

//──────────────────────────────── The Engine
jma_v13(src, _len) =>
    // 1. Hard-coded Parameters for Maximum Stability
    _ph    = -100.0 
    _pwr   = 0.1
    
    len    = math.max(_len, 2)
    ph_val = 0.5 // Mathematical result of -100 phase
    beta   = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
    
    // 2. Volatility Brain
    var float vSum = 0.0
    var volty_arr = array.new_float(10, 0.0)
    
    float del1 = src - nz(src[1], src)
    float volty = math.abs(del1)
    
    array.unshift(volty_arr, volty)
    float old_volty = array.pop(volty_arr)
    vSum := vSum + (volty - old_volty)
    
    float avgVolty = ta.sma(vSum * 0.1, 65)
    
    // 3. Relative Volatility
    float rvolty = (not na(avgVolty) and avgVolty > 0) ? volty / avgVolty : 1.0
    rvolty := math.min(math.max(rvolty, 0.1), math.pow(len, 10.0))
    
    // 4. Adaptive Alpha
    float pow_alpha = math.pow(rvolty, _pwr)
    float alpha = math.pow(beta, pow_alpha)
    
    // 5. State Variables
    var float ma1 = 0.0
    var float det0 = 0.0
    var float det1 = 0.0
    var float jma = 0.0
    
    // 6. RANGE LOCK LOGIC (Source-Aware)
    // We calculate the average of the selected source over the period
    float rangeAvg = ta.sma(src, len)
    
    // If Relative Volatility is low (Choppy), we use the Range Average
    // If it's high (Trend), we use the raw Source price
    float gatedSrc = rvolty < lockMult ? rangeAvg : src
    
    // 7. Calculation Cycle
    ma1  := (1 - alpha) * gatedSrc + alpha * nz(ma1[1], gatedSrc)
    det0 := (gatedSrc - ma1) * (1 - beta) + beta * nz(det0[1])
    float ma2 = ma1 + ph_val * det0
    
    float alphaSqr = math.pow(1 - alpha, 2)
    det1 := (ma2 - nz(jma[1], gatedSrc)) * alphaSqr + math.pow(alpha, 2) * nz(det1[1])
    jma  := nz(jma[1], gatedSrc) + det1
    jma

//──────────────────────────────── Execution
jmaVal = jma_v13(srcInput, period)

//──────────────────────────────── Coloring
float slope = jmaVal - nz(jmaVal[1], jmaVal)
// Dynamic noise floor for color changes
float noiseFloor = ta.stdev(slope, 30) * 0.15

color jmaColor = slope > noiseFloor ? color.lime : 
                 slope < -noiseFloor ? color.red : 
                 color.gray

//──────────────────────────────── Plotting
plot(jmaVal, "Source JMA", color=jmaColor, linewidth=3)
